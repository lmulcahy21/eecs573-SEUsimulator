from nathan_parser import Netlist, parse_netlist
from typing import List
import os

TB_FILENAME = "generated/testbench.sv"

TB_HEADER_DEFINES = """
/**
 *
 * This testbench file is generated by NATHAN.
 * Do not modify the testbench manually.
 *
 */


`timescale 1ps/1ps
`define PS(ticks) (ticks * 1)
`define NS(ticks) (ticks * 1000)
"""

# TB_MODULE_DEFINES_GEN

TB_MODULE_DECL = """
module testbench();

    import "DPI-C" function int force_net_by_name_dpi(input string netname, input int value);
    import "DPI-C" function int release_net_by_name_dpi(input string netname);
    import "DPI-C" function int get_net_value_by_name_dpi(input string netname);
    integer fd;
    integer idx_fd;
    logic [31:0] net_idx;
    integer num_masked_faults;
"""

# TB_NET_NAMES_GEN

# TB_PORTLIST_GEN

# TB_DUT_DECL_GEN

# TB_RUN_TEST_GEN

TB_INITIAL_BEGIN = """
    initial begin
"""

# TB_OPEN_FD_GEN

TB_INITIAL_END = """
        if (fd == 0) begin
            $display("Error opening file. Check path and permissions.");
            $finish;
        end

        num_masked_faults = 0;
        for (int i = 0; i < `NUM_CYCLES; i++) begin
            $readmemh(idx_fd, net_idx);
            run_test(net_names_dict[net_idx]);
        end

        $fwrite(fd, \"%d\\n\", num_masked_faults);
        $fclose(fd);
        $finish;
    end

endmodule
"""

def gen_testbench(netlist: Netlist, fault_nets: List[int], num_cycles: int):

    # Wire defines
    tb_module_defines_gen = ""
    tb_module_defines_gen += f"`define NUM_CYCLES {num_cycles}\n"
    tb_module_defines_gen += f"`define NUM_WIRES {len(netlist.gates)}\n"

    tb_net_names_gen = ""
    # for each fault net:
    #   - store name in array in testbench
    tb_net_names_gen += "\t// Netlist Dict\n"
    tb_net_names_gen += "\tstring net_names_dict[`NUM_WIRES] = '{\n"
    for i, (wire_name, wire) in enumerate(netlist.wires.items()):
        if wire.width > 1:
            netname, netidx = wire_name.rsplit('_', 1)
            tb_net_names_gen += f"\t\t\"testbench.dut.{netname}[{netidx}]\""
        else:
            tb_net_names_gen += f"\t\t\"testbench.dut.{wire}\""
        # style and commas
        if i != (len(netlist.wires) - 1):
            tb_net_names_gen += ","
        if i % 4 == 3:
            tb_net_names_gen += '\n'
    tb_net_names_gen += "\t};\n"


    #   - store index in 32-bit value,
    # write to generated file ({module}_net_indices_hex.gen)
    with (open(f"generated/{netlist.name}_net_indices_hex.gen", "w")) as f:
        for i in range(0, len(fault_nets)):
            f.write(f"{fault_nets[i]:04x}\n")

    INDEX_FILENAME= f"{os.getcwd()}/generated/{netlist.name}_net_indices_hex.gen"

    # Portlist generation
    tb_portlist_gen = ""
    tb_portlist_gen += "\n\t// Input Portlist\n"
    for input in netlist.inputs:
        tb_portlist_gen += f"\tlogic [{input[1]-1}:0] {input[0]};\n"
    tb_portlist_gen += "\n\t// Output Portlist\n"
    for output in netlist.outputs:
        tb_portlist_gen += f"\tlogic [{output[1]-1}:0] {output[0]};\n"
    tb_portlist_gen += "\n\t// Correct Output Variables for Validation\n"
    for output in netlist.outputs:
        tb_portlist_gen += f"\tlogic [{output[1]-1}:0] {output[0]}_correct;\n"
    # Module instantiation
    tb_dut_decl_gen = ""
    tb_dut_decl_gen += f"\n\t{netlist.name} dut (\n"
    tb_dut_decl_gen += "\t\t// Inputs\n"
    io_ports = netlist.inputs + netlist.outputs
    for i in range(0, len(io_ports)):
        port_name = io_ports[i][0]
        tb_dut_decl_gen += f"\t\t.{port_name} ({port_name})"
        if i != (len(io_ports) - 1):
            tb_dut_decl_gen += ","
        tb_dut_decl_gen += '\n'
    tb_dut_decl_gen += "\t);\n"
    # Testbench informational variables
    tb_run_test_gen = "\n\tlogic masked;\n"
    # setup task for running tests
    tb_run_test_gen += "\n\ttask run_test(input string net_name);\n"
    tb_run_test_gen += "\t\t//Drive Inputs\n"
    for input in netlist.inputs:
        tb_run_test_gen += f"\t\tassert(std::randomize({input[0]}));\n"
    tb_run_test_gen += "\t\t#(`NS(5)) // allow values to propagate\n"
    tb_run_test_gen += "\t\t//acquire correct outputs\n"
    for output in netlist.outputs:
        tb_run_test_gen += f"\t\t{output[0]}_correct = {output[0]};\n"
    tb_run_test_gen += "\t\t//force bitflip\n"
    tb_run_test_gen += "\t\tforce_net_by_name_dpi(net_name, ~get_net_value_by_name_dpi(net_name));\n"
    tb_run_test_gen += "\t\t#(`NS(5)) // allow values to propagate\n"
    tb_run_test_gen += "\t\tmasked =\n"
    for i in range(0, len(netlist.outputs)):
        output =  netlist.outputs[i]
        tb_run_test_gen += f"\t\t\t{output[0]} == {output[0]}_correct"
        if i != (len(netlist.outputs) - 1):
            tb_run_test_gen += " &&\n"
    tb_run_test_gen += ";\n"
    tb_run_test_gen += "\t\tnum_masked_faults = masked ? num_masked_faults + 1 : num_masked_faults;\n"
    tb_run_test_gen += "\t\t//release the net\n"
    tb_run_test_gen += "\t\trelease_net_by_name_dpi(net_name);\n"
    tb_run_test_gen += "\tendtask\n"
    # open file descriptor for logging
    tb_open_fd_gen = f"\t\tfd = $fopen(\"{os.getcwd()}/generated/tb_output.txt\", \"w\");"
    tb_open_fd_gen += f"\n\t\tidx_fd = $fopen(\"{INDEX_FILENAME}\", \"r\");\n"


    # build testbench string
    testbench_str = ""
    testbench_str += TB_HEADER_DEFINES
    testbench_str += tb_module_defines_gen
    testbench_str += TB_MODULE_DECL
    testbench_str += tb_net_names_gen
    testbench_str += tb_portlist_gen
    testbench_str += tb_dut_decl_gen
    testbench_str += tb_run_test_gen
    testbench_str += TB_INITIAL_BEGIN
    testbench_str += tb_open_fd_gen
    testbench_str += TB_INITIAL_END

    os.makedirs("generated", exist_ok=True)
    with open("generated/testbench.sv", "w") as f:
        f.write(testbench_str)

def test_main():
    netlists = parse_netlist("full_adder_64bit.vg")
    for module_name, netlist in netlists:
        gen_testbench(netlist, ["n272", "n273", "n274", "n275", "n276"], 5)

if __name__ == '__main__':
    test_main()