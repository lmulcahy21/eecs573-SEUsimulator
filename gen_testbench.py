from nathan_parser import Netlist, parse_netlist
from typing import List
import os
from nathan_types import TimingInfo

def gen_testbench_string(netlist: Netlist, timing_info: TimingInfo, num_faults: int, sdf_filename: str) -> str:
    filtered_wires = {key: value for (key, value) in netlist.wires.items() if not value.is_input}
    ##################################################
    #               TESTBENCH DEFINES                #
    ##################################################
    TB_DEFINES = \
f"""
/**
*
* This testbench file is generated by NATHAN.
* Do not modify the testbench manually (unless you reaaaallly want to).
*
*/

`timescale 1ps/1ps
`define PS(ticks) (ticks * 1)
`define NS(ticks) (ticks * 1000)
`define NUM_FAULTS {num_faults}
`define NUM_WIRES {len(filtered_wires)}
`define CLOCK_PERIOD `NS({timing_info.clock_period_ns})
`define T_SU `NS({timing_info.setup_time_ns})
`define T_HD `NS({timing_info.hold_time_ns})
`define TIMESTEP `PS(1)

"""

    ##################################################
    #               TESTBENCH HEADER                 #
    ##################################################
    TB_HEADER = \
f"""
module testbench();

    // backannotate modules with timing information
    initial $sdf_annotate("{sdf_filename}", golden);
    initial $sdf_annotate("{sdf_filename}", faulty);
    
    // DPI hooks for interacting with internal nets via name
    import "DPI-C" function int force_net_by_name_dpi(input string netname, input int value);
    import "DPI-C" function int release_net_by_name_dpi(input string netname);
    import "DPI-C" function int get_net_value_by_name_dpi(input string netname);

    // clock gen
    logic clock = 0;
    always begin
        #(`CLOCK_PERIOD / 2) clock = ~clock;
    end
"""

    ##################################################
    #                 NET NAMES DICT                 #
    ##################################################
    TB_NET_NAMES_DICT = ""
    TB_NET_NAMES_DICT += "\t// Netlist Dict\n"
    TB_NET_NAMES_DICT += "\tstring net_names_dict[`NUM_WIRES] = '{\n"
    for i, (wire_name, wire) in enumerate(filtered_wires.items()):
        if wire_name[0] == '\\':
            wire_name = '\\' + wire_name

        if wire.width > 1:
            netname, netidx = wire_name.rsplit('_', 1)
            TB_NET_NAMES_DICT += f"\t\t\"{netname}[{netidx}]\""
        else:
            TB_NET_NAMES_DICT += f"\t\t\"{wire_name}\""
        # style and commas
        if i != (len(filtered_wires) - 1):
            TB_NET_NAMES_DICT += ","
        if i % 8 == 7:
            TB_NET_NAMES_DICT += '\n'
    TB_NET_NAMES_DICT += "\t};\n"

    ##################################################
    #               DUT INSTANTIATION                #
    ##################################################
    TB_DUT_INST = ""
    # Portlist generation
    TB_DUT_INST += "\n\t// Input Portlist\n"
    for input in netlist.inputs:
        TB_DUT_INST += f"\tlogic [{input[1]-1}:0] {input[0]} ;\n"
    TB_DUT_INST += "\n\t// Output Portlist (golden)\n"
    for output in netlist.outputs:
        TB_DUT_INST += f"\tlogic [{output[1]-1}:0] {output[0]}_golden ;\n"
    TB_DUT_INST += "\n\t// Output Portlist (faulty)\n"
    for output in netlist.outputs:
        TB_DUT_INST += f"\tlogic [{output[1]-1}:0] {output[0]}_faulty ;\n"

    TB_DUT_INST += "\n\t// Output Portlist (faulty, old)\n"
    for output in netlist.outputs:
        TB_DUT_INST += f"\tlogic [{output[1]-1}:0] {output[0]}_faulty_old ;\n"

    # Module instantiation
    for mod in ["golden", "faulty"]:
        TB_DUT_INST += f"\n\t{netlist.name} {mod} (\n"
        TB_DUT_INST += "\t\t// Inputs\n"
        for input in netlist.inputs:
            TB_DUT_INST += f"\t\t. {input[0]} ( {input[0]} ),\n"
        TB_DUT_INST += "\t\t// Outputs\n"
        for i in range(0, len(netlist.outputs)):
            output = netlist.outputs[i]
            TB_DUT_INST += f"\t\t. {output[0]} ( {output[0]}_{mod} )"
            if i != (len(netlist.outputs) - 1):
                TB_DUT_INST += ","
            TB_DUT_INST += "\n"
        TB_DUT_INST += "\t);\n"

    ##################################################
    #               SIMULATION VARIABLES             #
    ##################################################
    TB_SIM_VARS = \
"""
    // seed
    int seed = 42;

    // Statistic counters maintained throughout campaign
    int  masked_timing = 0;   // 1) timing‑masked (between hold & setup)
    int  meta_hit      = 0;   // 2) setup/hold violation --> metastability
    int  masked_logic  = 0;   // 3) logic‑masked (fault crosses clock edge but doesn't have observable effects)
    int  observed      = 0;   // 4) captured & visible

    // intermediate variables
    int          sampled_idx;
    int          fault_start;
    int          fault_width; 
    time         fault_end;   
    logic        metastable; 
    logic        diverged;   
    time         edge_now;
    time         edge_next;
    time         hd_period_end;
    time         su_period_start; 
    time         last_diff;
    logic        is_timing_masked;
    string       net_name;
"""


    ##################################################
    #                   DIFF SIGNAL                  #
    ##################################################
    TB_DIFF_SIGNAL = \
"""
    // is there a difference between the two module outputs
    logic diff;
    assign diff =
"""
    for i in range(0, len(netlist.outputs)):
        output = netlist.outputs[i]
        TB_DIFF_SIGNAL += f"\t\t{output[0]}_faulty != {output[0]}_golden "
        if i != len(netlist.outputs) - 1:
            TB_DIFF_SIGNAL += " ||\n"
    TB_DIFF_SIGNAL += ";\n"

    ##################################################
    #                INITIAL BEGIN                   #
    ##################################################
    TB_INITIAL_BEGIN = \
f"""
    // fault injection campaign
    initial begin

        for (int i = 0; i < `NUM_FAULTS; i++) begin
            // sample a net from the netlist
            sampled_idx = $dist_uniform(seed, 0, `NUM_WIRES - 1);
            net_name = {{ \"testbench.faulty.\", net_names_dict[sampled_idx]}};

            // sample timing parameters for the pulse
            fault_start = $dist_uniform(seed, 0, `CLOCK_PERIOD - 1);
            fault_width = $dist_normal(seed, `PS(55), `PS(15));
            if (fault_width < 0) fault_width = 0;

"""

    ##################################################
    #                RANDOM INPUTS                   #
    ##################################################
    TB_RANDOM_INPUTS = \
"""
            // random inputs
            @(posedge clock);
"""
    for input in netlist.inputs:
        TB_RANDOM_INPUTS += f"\t\t\tassert(std::randomize( {input[0]} ));\n"

    ##################################################
    #                FAULT INJECTION                 #
    ##################################################
    old_assign_stmt = ""
    for output in netlist.outputs:
        old_assign_stmt += f"\t\t\t\t\t{output[0]}_faulty_old = {output[0]}_faulty ;\n"

    old_eq_check = ""
    for i in range(0, len(netlist.outputs)):
        output = netlist.outputs[i]
        old_eq_check += f"( {output[0]}_faulty != {output[0]}_faulty_old )"
        if i != len(netlist.outputs) - 1:
            old_eq_check += " ||\n"

    TB_FAULT_INJECTION = \
f"""
            // fault modeling routine
            @(posedge clock)
            fork
                //----- 1) inject the bit‑flip ---------------------------------------
                begin
                    #`PS(fault_start);
                    force_net_by_name_dpi(net_name, ~get_net_value_by_name_dpi(net_name));
                    #`PS(fault_width);
                    release_net_by_name_dpi(net_name);
                end

                //----- 2) watch outputs until next +edge ----------------------------
                begin
                    edge_now   = $time; // current rising edge
                    edge_next  = edge_now + `CLOCK_PERIOD;
                    hd_period_end = edge_now + `T_HD;
                    su_period_start = edge_next - `T_SU;

                    last_diff = 0;
                    metastable = 0;
                    diverged = 0;

                    // check for any divergence BEFORE the edge
                    while ($time < hd_period_end) begin
                        #(`TIMESTEP)
                        if (diff) begin
                            metastable = 1;
                            diverged = 1;
                            last_diff = $time;
                        end
                    end 


                    while ($time < su_period_start) begin
                        #(`TIMESTEP)
                        if (diff) begin
                            diverged = 1;
                            last_diff = $time;
                        end
                    end

{old_assign_stmt}

                    while ($time < (edge_next - 1)) begin  
                        #(`TIMESTEP)
                        if (diff) begin
                            last_diff = $time;
                            diverged = 1;
                        end
                        if ({old_eq_check}) begin 
                            metastable = 1;
                        end
                    end 


                    @(posedge clock);
{old_assign_stmt}

                    edge_now = $time;
                    while ($time < (edge_now + `T_HD)) begin
                        #(`TIMESTEP)
                        if (diff) begin
                            last_diff = $time;
                            diverged = 1;
                        end
                        if ({old_eq_check}) begin
                            metastable = 1;
                        end
                    end
                end
            join
"""

    ##################################################
    #                STATISTICS / END                #
    ##################################################
    TB_STATISTICS_END = \
"""
            is_timing_masked = 0;

            if (metastable) meta_hit++;
            if (!diverged)  masked_logic++;
            if (!metastable && diverged && (last_diff < (edge_now - `T_SU))) begin 
                masked_timing++;  // never reached sampling FF
                is_timing_masked = 1;
            end
            if (!metastable && diverged && !is_timing_masked) observed++; 
        end

        // print summary
        $display("\\n-----  fault‑injection summary (%%0d trials) -----", `NUM_FAULTS);
        $display("1) timing‑masked        : %%0d", masked_timing);
        $display("2) setup/hold violation : %%0d", meta_hit);
        $display("3) logic‑masked         : %%0d", masked_logic);
        $display("4) observed             : %%0d", observed);
        $finish;
    end

endmodule
"""

    testbench_str =  ""
    testbench_str += TB_DEFINES
    testbench_str += TB_HEADER
    testbench_str += TB_NET_NAMES_DICT
    testbench_str += TB_DUT_INST
    testbench_str += TB_SIM_VARS
    testbench_str += TB_DIFF_SIGNAL
    testbench_str += TB_INITIAL_BEGIN
    testbench_str += TB_RANDOM_INPUTS
    testbench_str += TB_FAULT_INJECTION
    testbench_str += TB_STATISTICS_END

    return testbench_str



def gen_testbench(netlist: Netlist, timing_info: TimingInfo, num_faults: int, sdf_filename: str):
    testbench_str = gen_testbench_string(netlist, timing_info, num_faults, sdf_filename)

    os.makedirs("generated", exist_ok=True)
    os.makedirs("generated/testbench", exist_ok=True)
    with open("generated/testbench/testbench.sv", "w") as f:
        f.write(testbench_str)

def test_main():
    netlists = parse_netlist("modules/full_adder_64bit.vg")
    for module_name, netlist in netlists:
        gen_testbench(netlist, TimingInfo(10, 0.05, 0.02), 1000, "sdf/full_adder_64bit.syn.sdf")

if __name__ == '__main__':
    test_main()